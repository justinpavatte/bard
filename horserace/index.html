<!doctype html>
<html lang="en">
<head>
  <!-- Need to run with Live Server for Firebase -->
  <!-- http://127.0.0.1:5500/horserace/index.html?player=Justin -->
  <!-- https://justinpavatte.github.io/bard/horserace/index.html?player=Justin -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horse Race</title>
  <!-- https://favicon.io/favicon-converter/ -->
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div id="topbar">
    <div id="playerInfo">Loading…</div>
    <div style="display:flex; gap:8px; align-items:center;">
      <div id="finishConfig">Finish: <span id="finishDistanceLabel"></span></div>
      <button id="adminResetBtn" class="challengeBtn hidden" title="Reset race for everyone">Reset Race</button>
    </div>
  </div>

  <div id="banner" class="hidden" role="status" aria-live="polite"></div>

  <main id="app">
    <section id="raceBoard" aria-live="polite"></section>

    <aside id="challengesWrap" class="hidden" aria-hidden="true">
      <h2 class="sr-only">Challenges</h2>
      <div id="challenges"></div>
    </aside>
  </main>

  <div id="toast" class="hidden" role="status" aria-live="polite"></div>

  <script type="module">
    import { sendTelegramMessage } from "./telegram.js";
    import { challenges } from "./challenges.js";

    /* =========================
       Solid Firebase loader (multi-CDN, multi-version)
       ========================= */
    const FIREBASE_CANDIDATE_VERS = ["11.0.0", "10.12.5"];
    const cdnVariants = (file, ver) => ([
      `https://www.gstatic.com/firebasejs/${ver}/${file}`,
      `https://cdn.jsdelivr.net/npm/firebase@${ver}/${file}`,
      `https://unpkg.com/firebase@${ver}/${file}`,
    ]);

    async function importFirst(urls) {
      let lastErr;
      for (const url of urls) {
        try { return await import(url); }
        catch (e) { lastErr = e; }
      }
      throw lastErr ?? new Error("All import attempts failed");
    }

    async function loadFirebaseModules() {
      for (const ver of FIREBASE_CANDIDATE_VERS) {
        try {
          const appMod = await importFirst(cdnVariants("firebase-app.js", ver));
          const dbMod  = await importFirst(cdnVariants("firebase-database.js", ver));
          return { appMod, dbMod, ver };
        } catch {}
      }
      throw new Error("No Firebase CDN candidate worked");
    }

    async function getDbFromUserConfig(appMod, dbMod) {
      try {
        const cfg = await import("./firebaseConfig.js");
        if (typeof cfg.initFirebase === "function") return cfg.initFirebase(appMod, dbMod);
        if (cfg.FIREBASE_CONFIG && typeof cfg.FIREBASE_CONFIG === "object") {
          const { initializeApp } = appMod;
          const { getDatabase } = dbMod;
          const app = initializeApp(cfg.FIREBASE_CONFIG);
          return getDatabase(app);
        }
        console.warn("firebaseConfig.js exports not recognized.");
        return null;
      } catch (e) {
        console.warn("firebaseConfig.js not found/failed to load:", e);
        return null;
      }
    }

    /* =========================
       App config
       ========================= */
    const FINISH_DISTANCE = 10; // exactly 10 completions to win
    const COMPLETE_DISABLE_MS = 900;
    const BOOT_FALLBACK_MS = 3500;

    const PLAYERS = [
      { name: "Jana", emoji: "🐎" },
      { name: "Elaina", emoji: "🐴" },
      { name: "Beverly", emoji: "🏇" },
      { name: "Justin", emoji: "🐂" }
    ];

    /* =========================
       DOM refs
       ========================= */
    const playerInfoEl = document.getElementById("playerInfo");
    const finishLabelEl = document.getElementById("finishDistanceLabel");
    const raceBoardEl = document.getElementById("raceBoard");
    const challengesWrap = document.getElementById("challengesWrap");
    const challengesEl = document.getElementById("challenges");
    const bannerEl = document.getElementById("banner");
    const toastEl = document.getElementById("toast");
    const adminResetBtn = document.getElementById("adminResetBtn");

    finishLabelEl && (finishLabelEl.textContent = FINISH_DISTANCE);

    /* =========================
       Identity
       ========================= */
    function getPlayerFromUrlOrStorage() {
      try {
        const url = new URL(location.href);
        const q = url.searchParams.get("player");
        if (q && q.trim()) {
          const clean = q.trim();
          localStorage.setItem("hr_player", clean);
          return clean;
        }
      } catch {}
      const stored = (localStorage.getItem("hr_player") || "").trim();
      if (stored) return stored;
      localStorage.setItem("hr_player", "Justin");
      return "Justin";
    }
    const currentPlayer = getPlayerFromUrlOrStorage();

    /* =========================
       Demo state
       ========================= */
    let demoState = {
      winner: null,
      race: PLAYERS.reduce((acc, p) => {
        acc[p.name] = { position: 0 };
        return acc;
      }, {})
    };

    /* =========================
       Helpers
       ========================= */
    function zeroRaceData() {
      return PLAYERS.reduce((acc, p) => {
        acc[p.name] = { position: 0 };
        return acc;
      }, {});
    }

    function showToast(text, timeout = 2500) {
      if (!toastEl) return;
      toastEl.textContent = text;
      toastEl.classList.remove("hidden");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toastEl.classList.add("hidden"), timeout);
    }

    function showBanner(text) {
      if (!bannerEl) return;
      bannerEl.textContent = text;
      bannerEl.classList.remove("hidden");
      runConfettiOnce();
    }

    function hideBanner() {
      bannerEl && bannerEl.classList.add("hidden");
    }

    // Robust pixel-based positioning so the horse never overshoots the flag
    function positionHorse(track, horse, finish, pos, max) {
      const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
      const startPad = 8; // same as CSS left:8px baseline
      const finishPad = 8; // same as .finishFlag right:8px

      const trackW = track.clientWidth;
      const horseW = horse.clientWidth || 0;
      const flagW  = finish.clientWidth || 0;

      // usable distance in px that the horse can travel
      const usable = Math.max(0, trackW - (startPad + finishPad) - horseW - flagW);

      const progress = clamp(Number(pos) / Number(max || 1), 0, 1);
      const leftPx = startPad + usable * progress;

      horse.style.left = `${Math.round(leftPx)}px`;
      // keep vertical centering via translateY, but don't translateX anymore
      horse.style.transform = `translateY(-50%)`;
    }

    function positionAllHorses() {
      document.querySelectorAll(".lane").forEach(lane => {
        const track = lane.querySelector(".track");
        const horse = lane.querySelector(".horse");
        const finish = lane.querySelector(".finishFlag");
        const meta = lane.querySelector(".laneMeta");
        if (!track || !horse || !finish) return;

        // read pos from meta text (e.g., "3/10")
        let pos = 0;
        if (meta && meta.textContent) {
          const m = meta.textContent.split("/")[0];
          pos = Number(m) || 0;
        }
        positionHorse(track, horse, finish, pos, FINISH_DISTANCE);
      });
    }

    // Reposition on resize/orientation changes
    const ro = new ResizeObserver(() => positionAllHorses());
    const observeTracks = () => {
      document.querySelectorAll(".track").forEach(t => ro.observe(t));
    };
    window.addEventListener("resize", positionAllHorses);
    window.addEventListener("orientationchange", positionAllHorses);

    function renderRaceBoard(raceData = {}) {
      raceBoardEl.innerHTML = "";
      PLAYERS.forEach(p => {
        const pos = (raceData[p.name] && typeof raceData[p.name].position === "number")
          ? raceData[p.name].position : 0;

        const lane = document.createElement("div");
        lane.className = "lane";
        lane.dataset.player = p.name;

        const label = document.createElement("div");
        label.className = "laneLabel";
        label.innerHTML = `<span class="horseEmoji">${p.emoji}</span><div>${p.name}</div>`;

        const track = document.createElement("div");
        track.className = "track";

        const finish = document.createElement("div");
        finish.className = "finishFlag";
        finish.textContent = "🏁";

        const horse = document.createElement("div");
        horse.className = "horse";
        horse.textContent = p.emoji;

        const meta = document.createElement("div");
        meta.className = "laneMeta";
        meta.textContent = `${pos}/${FINISH_DISTANCE}`;

        track.appendChild(horse);
        track.appendChild(finish);
        lane.appendChild(label);
        lane.appendChild(track);
        lane.appendChild(meta);
        raceBoardEl.appendChild(lane);

        // After in-DOM so sizes are correct
        requestAnimationFrame(() => {
          positionHorse(track, horse, finish, pos, FINISH_DISTANCE);
        });
      });

      // observe after rendering
      observeTracks();
    }

    function renderChallenges(winnerName = null) {
      if (!challengesEl) return;
      challengesEl.innerHTML = "";

      if (!currentPlayer) {
        challengesWrap && challengesWrap.classList.add("hidden");
        challengesWrap && challengesWrap.setAttribute("aria-hidden", "true");
        return;
      }

      const disabled = !!winnerName;

      challenges.forEach(ch => {
        const row = document.createElement("div");
        row.className = "challenge";

        const emoji = document.createElement("div");
        emoji.className = "challengeEmoji";
        emoji.textContent = ch.emoji;

        const label = document.createElement("div");
        label.className = "challengeLabel";
        label.textContent = ch.label;

        const btn = document.createElement("button");
        btn.className = "challengeBtn";
        btn.textContent = `Complete (+${ch.delta})`;
        btn.disabled = disabled;
        btn.onclick = () => handleComplete(ch, btn);

        row.appendChild(emoji);
        row.appendChild(label);
        row.appendChild(btn);
        challengesEl.appendChild(row);
      });

      if (disabled) {
        challengesWrap.classList.add("hidden");
        challengesWrap.setAttribute("aria-hidden", "true");
      } else {
        challengesWrap.classList.remove("hidden");
        challengesWrap.setAttribute("aria-hidden", "false");
      }
    }

    async function notifyTelegram(text) {
      try { await sendTelegramMessage(text); }
      catch (err) { console.warn("notifyTelegram error:", err); }
    }

    async function attemptSetWinner(candidateName) {
      if (demoMode) {
        if (!demoState.winner) {
          demoState.winner = candidateName;
          return true;
        }
        return false;
      }
      try {
        const { ref, runTransaction } = firebaseDB;
        const winnerRef = ref(db, "winner");
        const txnResult = await runTransaction(winnerRef, (cur) => cur || candidateName);
        const finalVal = txnResult.snapshot.val();
        return finalVal === candidateName;
      } catch (err) {
        console.warn("attemptSetWinner transaction failed", err);
        return false;
      }
    }

    async function handleComplete(challenge, btn) {
      if (!currentPlayer) {
        showToast("No player identity. Open URL with ?player=YourName");
        return;
      }
      if (btn) {
        btn.disabled = true;
        setTimeout(() => (btn.disabled = false), COMPLETE_DISABLE_MS);
      }

      if (demoMode) {
        const before = demoState.race[currentPlayer]?.position || 0;
        const after = before + Number(challenge.delta || 1);
        demoState.race[currentPlayer] = { position: after };
        renderRaceBoard(demoState.race);
        notifyTelegram(`🐎 ${currentPlayer} • ${challenge.id} (+${challenge.delta}) → pos ${after}/${FINISH_DISTANCE}`);
        if (after >= FINISH_DISTANCE) {
          const iSet = await attemptSetWinner(currentPlayer);
          if (iSet) notifyTelegram(`🏁 WINNER: ${currentPlayer} at ${after}/${FINISH_DISTANCE}`);
          showBanner(`🏁 ${currentPlayer} wins!`);
          renderChallenges(demoState.winner);
        }
        return;
      }

      try {
        const { ref, runTransaction } = firebaseDB;
        const playerPosRef = ref(db, `race/${currentPlayer}/position`);
        const res = await runTransaction(playerPosRef, (current) => {
          const a = Number(current ?? 0);
          const b = Number(challenge.delta ?? 1);
          return a + b;
        });

        if (!res.committed) { showToast("Try again"); return; }

        const posAfter = Number(res.snapshot.val());
        notifyTelegram(`🐎 ${currentPlayer} • ${challenge.id} (+${challenge.delta}) → pos ${posAfter}/${FINISH_DISTANCE}`);

        if (posAfter >= FINISH_DISTANCE) {
          const iSet = await attemptSetWinner(currentPlayer);
          if (iSet) notifyTelegram(`🏁 WINNER: ${currentPlayer} at ${posAfter}/${FINISH_DISTANCE}`);
        }
      } catch (err) {
        console.error("handleComplete error", err);
        showToast("Try again");
        if (btn) btn.disabled = false;
      }
    }

    /* =========================
       Admin reset (Justin only)
       ========================= */
    async function handleAdminReset() {
      if (!confirm("Reset the entire race for everyone? This clears the winner and sets all positions to 0.")) return;

      adminResetBtn.disabled = true;
      setTimeout(() => { adminResetBtn.disabled = false; }, 1200);

      if (demoMode) {
        demoState.winner = null;
        demoState.race = zeroRaceData();
        hideBanner();
        renderRaceBoard(demoState.race);
        renderChallenges(null);
        showToast("Race reset (demo)");
        try { await notifyTelegram("🔄 Race reset (demo mode)"); } catch {}
        return;
      }

      try {
        const { ref, set } = firebaseDB;
        await Promise.all([
          set(ref(db, "race"), zeroRaceData()),
          set(ref(db, "winner"), null)
        ]);
        hideBanner();
        showToast("Race reset");
        try { await notifyTelegram("🔄 Race reset by Justin"); } catch {}
      } catch (err) {
        console.error("Admin reset failed:", err);
        showToast("Reset failed");
      }
    }

    /* =========================
       Page mode + init
       ========================= */
    function initPageMode() {
      const name = (currentPlayer || "").trim();
      const lower = name.toLowerCase();

      if (name) {
        playerInfoEl && (playerInfoEl.textContent = `${name} — ${getEmojiForPlayer(name) || ""}`);
        challengesWrap && challengesWrap.classList.remove("hidden");
      } else {
        playerInfoEl && (playerInfoEl.textContent = "Spectator view");
        challengesWrap && challengesWrap.classList.add("hidden");
      }

      let adminOverride = false;
      try {
        const url = new URL(location.href);
        adminOverride = url.searchParams.get("admin") === "1";
      } catch {}
      const isJustin = lower === "justin" || adminOverride;

      if (isJustin) {
        adminResetBtn?.classList.remove("hidden");
        adminResetBtn?.removeEventListener("click", handleAdminReset);
        adminResetBtn?.addEventListener("click", handleAdminReset);
      } else {
        adminResetBtn?.classList.add("hidden");
      }
    }
    function getEmojiForPlayer(name) {
      const p = PLAYERS.find(x => x.name === name);
      return p ? p.emoji : "";
    }

    /* =========================
       Confetti (one-time)
       ========================= */
    function runConfettiOnce() {
      if (runConfettiOnce._done) return;
      runConfettiOnce._done = true;

      const root = document.createElement("div");
      root.style.position = "fixed";
      root.style.left = 0;
      root.style.top = 0;
      root.style.right = 0;
      root.style.bottom = 0;
      root.style.pointerEvents = "none";
      root.style.zIndex = 9999;

      for (let i = 0; i < 32; i++) {
        const el = document.createElement("div");
        el.style.position = "absolute";
        el.style.left = Math.random() * 100 + "%";
        el.style.top = "-8%";
        el.style.width = `${8 + Math.random() * 10}px`;
        el.style.height = `${10 + Math.random() * 16}px`;
        el.style.opacity = "0.95";
        el.style.transform = `rotate(${Math.random() * 360}deg)`;
        el.style.background = `hsl(${Math.round(Math.random()*60 + 20)}, 80%, 60%)`;
        el.style.borderRadius = "2px";
        el.style.transition = `transform 1200ms ease-out, top 1200ms ease-in, opacity 1200ms`;
        root.appendChild(el);

        requestAnimationFrame(() => {
          el.style.top = (60 + Math.random() * 40) + "%";
          el.style.transform = `translateY(0) rotate(${Math.random() * 720}deg)`;
          el.style.opacity = "0";
        });
      }

      document.body.appendChild(root);
      setTimeout(() => root.remove(), 1400);
    }

    /* =========================
       Firebase init with safe fallback
       ========================= */
    let db = null;
    let demoMode = false;
    let unsubRace = null;
    let unsubWinner = null;
    let firebaseDB = null;

    function fallbackToDemo(reason = "Offline demo mode") {
      if (unsubRace) { try { unsubRace(); } catch {} }
      if (unsubWinner) { try { unsubWinner(); } catch {} }
      demoMode = true;
      console.warn("Falling back to demo:", reason);
      showToast(reason);
      hideBanner();
      renderRaceBoard(demoState.race);
      renderChallenges(null);
    }

    initPageMode();
    renderRaceBoard(zeroRaceData());
    renderChallenges(null);
    if (!currentPlayer) document.body.classList.add("spectator");

    let bootTimer = null;

    try {
      const { appMod, dbMod } = await loadFirebaseModules();
      firebaseDB = dbMod;

      db = await getDbFromUserConfig(appMod, dbMod);
      if (!db) throw new Error("No Firebase config or init function provided");

      bootTimer = setTimeout(() => {
        fallbackToDemo("No realtime data — demo mode");
      }, BOOT_FALLBACK_MS);

      const { ref, onValue } = dbMod;

      unsubRace = onValue(ref(db, "race"), (snapshot) => {
        clearTimeout(bootTimer);
        const data = snapshot.val() || {};
        for (const k of Object.keys(data)) {
          if (data[k] && typeof data[k].position === "string") {
            data[k].position = Number(data[k].position);
          }
        }
        renderRaceBoard(data);
        // ensure correct placement after data updates
        requestAnimationFrame(positionAllHorses);
      }, (err) => {
        console.error("race onValue error", err);
        fallbackToDemo("Realtime error — demo mode");
      });

      unsubWinner = onValue(ref(db, "winner"), (snap) => {
        const w = snap.exists() ? snap.val() : null;
        if (w) {
          showBanner(`🏁 ${w} wins!`);
          renderChallenges(w);
        } else {
          hideBanner();
          renderChallenges(null);
        }
      }, (err) => {
        console.error("winner onValue error", err);
        hideBanner();
      });

      console.log("Firebase loaded via CDN (version fallback) and initialized.");
    } catch (e) {
      console.warn("Firebase unavailable or misconfigured:", e);
      fallbackToDemo("Firebase unavailable — demo mode");
    }
  </script>

  <noscript>
    This app requires JavaScript. Please enable JavaScript to use the Horse Race app.
  </noscript>
</body>
</html>
