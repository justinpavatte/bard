<!doctype html>
<html lang="en">
<head>
  <!-- Need to run with Live Server for Firebase -->
  <!-- http://127.0.0.1:5500/horserace/index.html?player=Justin -->
  <!-- https://justinpavatte.github.io/bard/horserace/index.html?player=Justin -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Horse Race</title>
  <!-- https://favicon.io/favicon-converter/ -->
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div id="topbar">
    <div id="playerInfo">Loading…</div>
    <div style="display:flex; gap:8px; align-items:center;">
      <div id="finishConfig">Finish: <span id="finishDistanceLabel"></span></div>
      <button id="adminResetBtn" class="challengeBtn hidden" title="Reset race for everyone">Reset Race</button>
    </div>
  </div>

  <div id="banner" class="hidden" role="status" aria-live="polite"></div>

  <main id="app">
    <section id="raceBoard" aria-live="polite"></section>

    <aside id="challengesWrap" class="hidden" aria-hidden="true">
      <h2 class="sr-only">Challenges</h2>
      <div id="challenges"></div>
    </aside>
  </main>

  <div id="toast" class="hidden" role="status" aria-live="polite"></div>

  <script type="module">
    import { sendTelegramMessage } from "./telegram.js";
    import { challenges } from "./challenges.js";

    /* =========================
       Solid Firebase loader (multi-CDN, multi-version)
       ========================= */
    const FIREBASE_CANDIDATE_VERS = ["11.0.0", "10.12.5"];
    const cdnVariants = (file, ver) => ([
      `https://www.gstatic.com/firebasejs/${ver}/${file}`,
      `https://cdn.jsdelivr.net/npm/firebase@${ver}/${file}`,
      `https://unpkg.com/firebase@${ver}/${file}`,
    ]);

    async function importFirst(urls) {
      let lastErr;
      for (const url of urls) {
        try { return await import(url); }
        catch (e) { lastErr = e; }
      }
      throw lastErr ?? new Error("All import attempts failed");
    }

    async function loadFirebaseModules() {
      for (const ver of FIREBASE_CANDIDATE_VERS) {
        try {
          const appMod = await importFirst(cdnVariants("firebase-app.js", ver));
          const dbMod  = await importFirst(cdnVariants("firebase-database.js", ver));
          return { appMod, dbMod, ver };
        } catch {}
      }
      throw new Error("No Firebase CDN candidate worked");
    }

    // Try to load user's firebaseConfig.js dynamically.
    // Supported exports:
    //   export function initFirebase(appMod, dbMod) { ... return rtdbOrNull }
    //   OR export const FIREBASE_CONFIG = { apiKey: "...", ... }
    async function getDbFromUserConfig(appMod, dbMod) {
      try {
        const cfg = await import("./firebaseConfig.js");
        if (typeof cfg.initFirebase === "function") return cfg.initFirebase(appMod, dbMod);
        if (cfg.FIREBASE_CONFIG && typeof cfg.FIREBASE_CONFIG === "object") {
          const { initializeApp } = appMod;
          const { getDatabase } = dbMod;
          const app = initializeApp(cfg.FIREBASE_CONFIG);
          return getDatabase(app);
        }
        console.warn("firebaseConfig.js exports not recognized.");
        return null;
      } catch (e) {
        console.warn("firebaseConfig.js not found/failed to load:", e);
        return null;
      }
    }

    /* =========================
       App config
       ========================= */
    const FINISH_DISTANCE = 10; // exactly 10 completions to win
    const COMPLETE_DISABLE_MS = 900;
    const BOOT_FALLBACK_MS = 3500;

    const PLAYERS = [
      { name: "Jana", emoji: "🐎" },
      { name: "Elaina", emoji: "🐴" },
      { name: "Beverly", emoji: "🏇" },
      { name: "Justin", emoji: "🐂" }
    ];

    /* =========================
       DOM refs
       ========================= */
    const playerInfoEl = document.getElementById("playerInfo");
    const finishLabelEl = document.getElementById("finishDistanceLabel");
    const raceBoardEl = document.getElementById("raceBoard");
    const challengesWrap = document.getElementById("challengesWrap");
    const challengesEl = document.getElementById("challenges");
    const bannerEl = document.getElementById("banner");
    const toastEl = document.getElementById("toast");
    const adminResetBtn = document.getElementById("adminResetBtn");

    finishLabelEl && (finishLabelEl.textContent = FINISH_DISTANCE);

    /* =========================
       Identity
       ========================= */
    function getPlayerFromUrlOrStorage() {
      try {
        const url = new URL(location.href);
        const q = url.searchParams.get("player");
        if (q && q.trim()) {
          const clean = q.trim();
          localStorage.setItem("hr_player", clean);
          return clean;
        }
      } catch {}
      const stored = (localStorage.getItem("hr_player") || "").trim();
      if (stored) return stored;
      localStorage.setItem("hr_player", "Justin");
      return "Justin";
    }
    const currentPlayer = getPlayerFromUrlOrStorage();

    /* =========================
       Demo state
       ========================= */
    let demoState = {
      winner: null,
      race: PLAYERS.reduce((acc, p) => {
        acc[p.name] = { position: 0 };
        return acc;
      }, {})
    };

    /* =========================
       Positioning helpers (pixel-precise)
       ========================= */
    function positionHorse(track, horse, finish, pos, max) {
      const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
      const startPad = 8;   // same as CSS left:8px baseline
      const finishPad = 8;  // same as .finishFlag right:8px

      const trackW = track.clientWidth;
      const horseW = horse.clientWidth || 0;
      const flagW  = finish.clientWidth || 0;

      // distance the horse can travel without overlapping the flag
      const usable = Math.max(0, trackW - (startPad + finishPad) - horseW - flagW);

      const progress = clamp(Number(pos) / Number(max || 1), 0, 1);
      const leftPx = startPad + usable * progress;

      horse.style.left = `${Math.round(leftPx)}px`;
      horse.style.transform = `translateY(-50%)`; // keep vertical centering
    }

    /* =========================
       Build once + update only (no DOM rebuild => no snap back)
       ========================= */
    const UI = {
      built: false,
      lanes: new Map(), // name -> { lane, track, horse, finish, meta, mounted }
      ro: null,
    };

    // Keep the current player's lane at the bottom of the list (visual only)
    function putCurrentPlayerAtBottom() {
    if (!currentPlayer) return;
    const lanes = Array.from(raceBoardEl.children);
    const mine = lanes.find(el => el.dataset && el.dataset.player === currentPlayer);
    if (mine) raceBoardEl.appendChild(mine); // appending reorders to end
    }

    // NEW: two-row layout per lane
    function buildRaceBoard() {
      raceBoardEl.innerHTML = "";
      UI.lanes.clear();
      if (UI.ro) { try { UI.ro.disconnect(); } catch {} }
      UI.ro = new ResizeObserver(() => positionAllHorses());

      PLAYERS.forEach(p => {
        const lane = document.createElement("div");
        lane.className = "lane";
        lane.dataset.player = p.name;

        // Row 1: name (left) and position meta (right)
        const header = document.createElement("div");
        header.className = "laneHeader";

        const headerLeft = document.createElement("div");
        headerLeft.className = "left";
        headerLeft.innerHTML = `<div>${p.name}</div>`;

        const meta = document.createElement("div");
        meta.className = "laneMeta";
        meta.textContent = `0/${FINISH_DISTANCE}`;

        header.appendChild(headerLeft);
        header.appendChild(meta);

        // Row 2: track with horse + finish flag
        const trackRow = document.createElement("div");
        trackRow.className = "trackRow";

        const track = document.createElement("div");
        track.className = "track";

        const horse = document.createElement("div");
        horse.className = "horse";
        horse.textContent = p.emoji;

        const finish = document.createElement("div");
        finish.className = "finishFlag";
        finish.textContent = "🏁";

        track.appendChild(horse);
        track.appendChild(finish);
        trackRow.appendChild(track);

        lane.appendChild(header);
        lane.appendChild(trackRow);
        raceBoardEl.appendChild(lane);

        UI.ro.observe(track);
        UI.lanes.set(p.name, { lane, track, horse, finish, meta, mounted: false });
      });

      UI.built = true;
      
      // Move current player's lane to the bottom once, after initial render
      putCurrentPlayerAtBottom();

      // First positioning after everything is in the DOM
      requestAnimationFrame(positionAllHorses);
    }

    function updateRaceBoard(raceData = {}) {
      if (!UI.built) buildRaceBoard();

      PLAYERS.forEach(p => {
        const ui = UI.lanes.get(p.name);
        if (!ui) return;

        const pos = (raceData[p.name] && typeof raceData[p.name].position === "number")
          ? raceData[p.name].position : 0;

        ui.meta.textContent = `${pos}/${FINISH_DISTANCE}`;

        // On first paint: set without transition to avoid a jump
        if (!ui.mounted) {
          const prev = ui.horse.style.transition;
          ui.horse.style.transition = "none";
          positionHorse(ui.track, ui.horse, ui.finish, pos, FINISH_DISTANCE);
          void ui.horse.offsetWidth; // reflow
          ui.horse.style.transition = prev || "";
          ui.mounted = true;
        } else {
          positionHorse(ui.track, ui.horse, ui.finish, pos, FINISH_DISTANCE);
        }
      });
    }

    function positionAllHorses() {
      UI.lanes.forEach(({ track, horse, finish, meta }) => {
        const [cur = "0"] = (meta.textContent || "").split("/");
        positionHorse(track, horse, finish, Number(cur) || 0, FINISH_DISTANCE);
      });
    }

    window.addEventListener("resize", positionAllHorses);
    window.addEventListener("orientationchange", positionAllHorses);

    // Extra passes so small iOS screens measure correctly
    window.addEventListener('load', () => { positionAllHorses(); });
    if ('fonts' in document && document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => { positionAllHorses(); }).catch(()=>{});
    }

    /* =========================
       Other UI helpers
       ========================= */
    function zeroRaceData() {
      return PLAYERS.reduce((acc, p) => {
        acc[p.name] = { position: 0 };
        return acc;
      }, {});
    }

    function showToast(text, timeout = 2500) {
      if (!toastEl) return;
      toastEl.textContent = text;
      toastEl.classList.remove("hidden");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toastEl.classList.add("hidden"), timeout);
    }

    function showBanner(text) {
      if (!bannerEl) return;
      bannerEl.textContent = text;
      bannerEl.classList.remove("hidden");
      runConfettiOnce();
    }

    function hideBanner() {
      bannerEl && bannerEl.classList.add("hidden");
    }

    function renderChallenges(winnerName = null) {
      if (!challengesEl) return;
      challengesEl.innerHTML = "";

      if (!currentPlayer) {
        challengesWrap && challengesWrap.classList.add("hidden");
        challengesWrap && challengesWrap.setAttribute("aria-hidden", "true");
        return;
      }

      const disabled = !!winnerName;

      challenges.forEach(ch => {
        const row = document.createElement("div");
        row.className = "challenge";

        const emoji = document.createElement("div");
        emoji.className = "challengeEmoji";
        emoji.textContent = ch.emoji;

        const label = document.createElement("div");
        label.className = "challengeLabel";
        label.textContent = ch.label;

        const btn = document.createElement("button");
        btn.className = "challengeBtn";
        btn.textContent = `Complete`; // no +1
        btn.disabled = disabled;
        btn.onclick = () => handleComplete(ch, btn);

        row.appendChild(emoji);
        row.appendChild(label);
        row.appendChild(btn);
        challengesEl.appendChild(row);
      });

      if (disabled) {
        challengesWrap.classList.add("hidden");
        challengesWrap.setAttribute("aria-hidden", "true");
      } else {
        challengesWrap.classList.remove("hidden");
        challengesWrap.setAttribute("aria-hidden", "false");
      }
    }

    async function notifyTelegram(text) {
      try { await sendTelegramMessage(text); }
      catch (err) { console.warn("notifyTelegram error:", err); }
    }

    async function attemptSetWinner(candidateName) {
      if (demoMode) {
        if (!demoState.winner) {
          demoState.winner = candidateName;
          return true;
        }
        return false;
      }
      try {
        const { ref, runTransaction } = firebaseDB;
        const winnerRef = ref(db, "winner");
        const txnResult = await runTransaction(winnerRef, (cur) => cur || candidateName);
        const finalVal = txnResult.snapshot.val();
        return finalVal === candidateName;
      } catch (err) {
        console.warn("attemptSetWinner transaction failed", err);
        return false;
      }
    }

    async function handleComplete(challenge, btn) {
      if (!currentPlayer) {
        showToast("No player identity. Open URL with ?player=YourName");
        return;
      }
      if (btn) {
        btn.disabled = true;
        setTimeout(() => (btn.disabled = false), COMPLETE_DISABLE_MS);
      }

      if (demoMode) {
        const before = demoState.race[currentPlayer]?.position || 0;
        const after = before + Number(challenge.delta || 1);
        demoState.race[currentPlayer] = { position: after };
        updateRaceBoard(demoState.race);
        notifyTelegram(`🐎 ${currentPlayer} • ${challenge.id} (+${challenge.delta}) → pos ${after}/${FINISH_DISTANCE}`);
        if (after >= FINISH_DISTANCE) {
          const iSet = await attemptSetWinner(currentPlayer);
          if (iSet) notifyTelegram(`🏁 WINNER: ${currentPlayer} at ${after}/${FINISH_DISTANCE}`);
          showBanner(`🏁 ${currentPlayer} wins!`);
          renderChallenges(demoState.winner);
        }
        return;
      }

      try {
        const { ref, runTransaction } = firebaseDB;
        const playerPosRef = ref(db, `race/${currentPlayer}/position`);
        const res = await runTransaction(playerPosRef, (current) => {
          const a = Number(current ?? 0);
          const b = Number(challenge.delta ?? 1);
          return a + b;
        });

        if (!res.committed) { showToast("Try again"); return; }

        const posAfter = Number(res.snapshot.val());
        notifyTelegram(`🐎 ${currentPlayer} • ${challenge.id} (+${challenge.delta}) → pos ${posAfter}/${FINISH_DISTANCE}`);

        if (posAfter >= FINISH_DISTANCE) {
          const iSet = await attemptSetWinner(currentPlayer);
          if (iSet) notifyTelegram(`🏁 WINNER: ${currentPlayer} at ${posAfter}/${FINISH_DISTANCE}`);
        }
      } catch (err) {
        console.error("handleComplete error", err);
        showToast("Try again");
        if (btn) btn.disabled = false;
      }
    }

    /* =========================
       Admin reset (Justin only)
       ========================= */
    async function handleAdminReset() {
      if (!confirm("Reset the entire race for everyone? This clears the winner and sets all positions to 0.")) return;

      adminResetBtn.disabled = true;
      setTimeout(() => { adminResetBtn.disabled = false; }, 1200);

      if (demoMode) {
        demoState.winner = null;
        demoState.race = zeroRaceData();
        hideBanner();
        updateRaceBoard(demoState.race);
        renderChallenges(null);
        showToast("Race reset (demo)");
        try { await notifyTelegram("🔄 Race reset (demo mode)"); } catch {}
        return;
      }

      try {
        const { ref, set } = firebaseDB;
        await Promise.all([
          set(ref(db, "race"), zeroRaceData()),
          set(ref(db, "winner"), null)
        ]);
        hideBanner();
        showToast("Race reset");
        // optional immediate visual reset before Firebase round-trip:
        updateRaceBoard(zeroRaceData());
        try { await notifyTelegram("🔄 Race reset by Justin"); } catch {}
      } catch (err) {
        console.error("Admin reset failed:", err);
        showToast("Reset failed");
      }
    }

    /* =========================
       Page mode + init
       ========================= */
    function initPageMode() {
      const name = (currentPlayer || "").trim();
      const lower = name.toLowerCase();

      if (name) {
        playerInfoEl && (playerInfoEl.textContent = `${name} — ${getEmojiForPlayer(name) || ""}`);
        challengesWrap && challengesWrap.classList.remove("hidden");
      } else {
        playerInfoEl && (playerInfoEl.textContent = "Spectator view");
        challengesWrap && challengesWrap.classList.add("hidden");
      }

      let adminOverride = false;
      try {
        const url = new URL(location.href);
        adminOverride = url.searchParams.get("admin") === "1";
      } catch {}
      const isJustin = lower === "justin" || adminOverride;

      if (isJustin) {
        adminResetBtn?.classList.remove("hidden");
        adminResetBtn?.removeEventListener("click", handleAdminReset);
        adminResetBtn?.addEventListener("click", handleAdminReset);
      } else {
        adminResetBtn?.classList.add("hidden");
      }
    }
    function getEmojiForPlayer(name) {
      const p = PLAYERS.find(x => x.name === name);
      return p ? p.emoji : "";
    }

    /* =========================
       Confetti (one-time)
       ========================= */
    function runConfettiOnce() {
      if (runConfettiOnce._done) return;
      runConfettiOnce._done = true;

      const root = document.createElement("div");
      root.style.position = "fixed";
      root.style.left = 0;
      root.style.top = 0;
      root.style.right = 0;
      root.style.bottom = 0;
      root.style.pointerEvents = "none";
      root.style.zIndex = 9999;

      for (let i = 0; i < 32; i++) {
        const el = document.createElement("div");
        el.style.position = "absolute";
        el.style.left = Math.random() * 100 + "%";
        el.style.top = "-8%";
        el.style.width = `${8 + Math.random() * 10}px`;
        el.style.height = `${10 + Math.random() * 16}px`;
        el.style.opacity = "0.95";
        el.style.transform = `rotate(${Math.random() * 360}deg)`;
        el.style.background = `hsl(${Math.round(Math.random()*60 + 20)}, 80%, 60%)`;
        el.style.borderRadius = "2px";
        el.style.transition = `transform 1200ms ease-out, top 1200ms ease-in, opacity 1200ms`;
        root.appendChild(el);

        requestAnimationFrame(() => {
          el.style.top = (60 + Math.random() * 40) + "%";
          el.style.transform = `translateY(0) rotate(${Math.random() * 720}deg)`;
          el.style.opacity = "0";
        });
      }

      document.body.appendChild(root);
      setTimeout(() => root.remove(), 1400);
    }

    /* =========================
       Firebase init with safe fallback
       ========================= */
    let db = null;
    let demoMode = false;
    let unsubRace = null;
    let unsubWinner = null;
    let firebaseDB = null;

    function fallbackToDemo(reason = "Offline demo mode") {
      if (unsubRace) { try { unsubRace(); } catch {} }
      if (unsubWinner) { try { unsubWinner(); } catch {} }
      demoMode = true;
      console.warn("Falling back to demo:", reason);
      showToast(reason);
      hideBanner();
      updateRaceBoard(demoState.race);
      renderChallenges(null);
    }

    // Initial UI: build lanes once, then set zeros
    initPageMode();
    buildRaceBoard();
    updateRaceBoard(PLAYERS.reduce((a,p)=> (a[p.name]={position:0}, a), {}));
    renderChallenges(null);
    if (!currentPlayer) document.body.classList.add("spectator");

    let bootTimer = null;

    try {
      const { appMod, dbMod } = await loadFirebaseModules();
      firebaseDB = dbMod;

      db = await getDbFromUserConfig(appMod, dbMod);
      if (!db) throw new Error("No Firebase config or init function provided");

      bootTimer = setTimeout(() => {
        fallbackToDemo("No realtime data — demo mode");
      }, BOOT_FALLBACK_MS);

      const { ref, onValue } = dbMod;

      unsubRace = onValue(ref(db, "race"), (snapshot) => {
        clearTimeout(bootTimer);
        const data = snapshot.val() || {};
        for (const k of Object.keys(data)) {
          if (data[k] && typeof data[k].position === "string") {
            data[k].position = Number(data[k].position);
          }
        }
        updateRaceBoard(data);
        requestAnimationFrame(positionAllHorses);
      }, (err) => {
        console.error("race onValue error", err);
        fallbackToDemo("Realtime error — demo mode");
      });

      unsubWinner = onValue(ref(db, "winner"), (snap) => {
        const w = snap.exists() ? snap.val() : null;
        if (w) {
          showBanner(`🏁 ${w} wins!`);
          renderChallenges(w);
        } else {
          hideBanner();
          renderChallenges(null);
        }
      }, (err) => {
        console.error("winner onValue error", err);
        hideBanner();
      });

      console.log("Firebase loaded via CDN (version fallback) and initialized.");
    } catch (e) {
      console.warn("Firebase unavailable or misconfigured:", e);
      fallbackToDemo("Firebase unavailable — demo mode");
    }
  </script>

  <noscript>
    This app requires JavaScript. Please enable JavaScript to use the Horse Race app.
  </noscript>
</body>
</html>
